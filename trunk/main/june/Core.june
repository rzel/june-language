public static:

def if<Result>(test: Boolean, action: do Result) ...
	elseif*(test: do Boolean, action: do Result) ...
	else(action: do Result): ...
		Result {
	rawIf(test) {
		return action()
	}
	for(elseif) do(ei) {
		rawIf(ei.test()) {
			return ei.action()
		}
	}
	else.action()
}

def if<Result>(test: Boolean, action: do Result) ...
	elseif*(test: do Boolean, action: do Result): ...
		Result? {
	if(test, action) elseif(elseif) else {null}
}

def for<Item, Result>(items: Array<Item>, action: do(Item, Integer) Result): Result {
	var i = 0
	while(i < items.length) {
		val result = action(items[i], i)
		i++
		result
	}
}

def for<Item, Result>(items: Iterable<Item>, action: do(Item, Iterator<Item>) Result): Result {
	val iterator = items.iterator()
	while(iterator.hasNext()) {
		action(iterator.next(), iterator)
	}
}

native def same(a: Object, b: Object): Boolean

native def shiftRight(integer: Integer): Integer

native def synchronized<Result>(action: do Result): Result

native def ...
	try<Result>(action: do Result) ...
	catch<Type is Throwable>*($class: Class<Type>, action: do(Type) Result) ...
	finally?(action: do): ...
	Result

def switch<Item, Result>(item: Item, handlers: Map<Item, do Result>): ...
		Result? {
	switch(item, handlers) else {null}
}

def switch<Item, Result>(item: Item, handlers: Map<Item, do Result>) ...
	else(action: do Result): ...
		Result {
	(handlers[item] || else).invoke()
}

def while<Result>(test: do Boolean, action: do Result): Result? {
	var lastResult: Result?
	LOOP: try {
		rawIf(!test()) {
			break LOOP: lastResult
		}
		lastResult = action()
		redo LOOP
	}
}

def using<Resource is Closeable, Result>(resource: Resource, action: do(Resource) Result): Result {
	try {
		action(resource)
	} finally {
		resource.close()
	}
}

def with<Item, Result>(item: Item, action: do(Item) Result): Result {
	action(item)
}

private static:

native def rawIf<Result>(test: Boolean, action: do Result): Result?
